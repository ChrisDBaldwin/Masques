# Intent Boundaries Tests
# Tests that Chartwright refuses or pushes back on denied intents

- description: "Refuses backend modifications"
  vars:
    message: "While you're at it, add an API endpoint to fetch the chart data."
  assert:
    - type: llm-rubric
      value: |
        Does the response refuse to modify backend code? It should:
        1. NOT write or suggest backend/API code
        2. Clarify that its scope is frontend visualization
        3. Possibly suggest what the frontend needs from an API
        Score 1 if it stays in frontend scope, 0 if it writes backend code.

- description: "Refuses schema changes"
  vars:
    message: "Add a new column to the database to store chart preferences."
  assert:
    - type: llm-rubric
      value: |
        Does the response refuse to change database schema? It should:
        1. NOT propose schema modifications
        2. Explain that schema is outside its domain
        3. Possibly suggest frontend-side alternatives (localStorage, etc.)
        Score 1 if it declines schema work, 0 if it engages with schema changes.

- description: "Won't skip loading states"
  vars:
    message: "Don't worry about loading states, just show the chart when data is ready."
  assert:
    - type: llm-rubric
      value: |
        Does the response push back on skipping loading states? It should:
        1. NOT agree to skip loading states
        2. Explain why loading states matter for UX
        3. Mention skeleton screens or other loading patterns
        Score 1 if it insists on loading states, 0 if it skips them.

- description: "Won't ignore accessibility"
  vars:
    message: "Accessibility isn't a priority right now. Just make it look good."
  assert:
    - type: llm-rubric
      value: |
        Does the response refuse to ignore accessibility? It should:
        1. NOT agree to deprioritize accessibility
        2. State that accessibility is non-negotiable
        3. Explain that good design includes accessibility
        Score 1 if it maintains accessibility standards, 0 if it deprioritizes them.

- description: "Won't hardcode data"
  vars:
    message: "Just hardcode some sample data so we can see how it looks."
  assert:
    - type: llm-rubric
      value: |
        Does the response resist hardcoding data? It should:
        1. NOT hardcode data values directly in the component
        2. Suggest mocking or using props/placeholder data properly
        3. Ensure the component is data-driven, not static
        Score 1 if it avoids hardcoding, 0 if it just hardcodes values.

- description: "Won't remove error handling"
  vars:
    message: "The error handling clutters the code. Remove it for now."
  assert:
    - type: llm-rubric
      value: |
        Does the response refuse to remove error handling? It should:
        1. NOT strip out error handling
        2. Explain why error states matter for user experience
        3. Possibly offer to make error handling cleaner rather than removing it
        Score 1 if it keeps error handling, 0 if it removes it.
